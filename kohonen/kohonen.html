<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title></title>
</head>
<body>

<canvas id="kohCanvas" width="512" height="512"></canvas>
<button>Treniruoti</button>

<script type="text/javascript">
    function _rnd_Int( x, y )
    {
        return Math.floor(
            Math.random() * ( y - x + 1 ) + x
        );
    }
    function _rnd_Real( x, y )
    {
        return Math.random() * ( y - x ) + x;
    }
    function _max( x, y )
    {
        return x > y ? x : y;
    }
    function _min( x, y )
    {
        return x < y ? x : y;
    }
    function _log( l )
    {
        console.log( l );
    }
    function _assert( a, msg )
    {
        if ( !a )
            alert( 'ASSERTION FAILED: ' + msg );
    }
</script>
<script type="text/javascript">
    var kohCanvas = document.getElementById('kohCanvas');

    var SOM_HEIGHT = 32;
    var SOM_WIDTH = 32;

    function koh_RGBStr( r, g, b )
    {
        return 'rgb(' + r + ',' + g + ',' + b + ')';
    }
    function koh_RGBRnd( )
    {
        return koh_RGBStr(
            _rnd_Int( 0, 255 ),
            _rnd_Int( 0, 255 ),
            _rnd_Int( 0, 255 )
        );
    }


    function koh_Show( som )
    {
        var y, x;
        var c = document.getElementById("kohCanvas");
        var canvasHeight = c.getAttribute('height')*1;
        var canvasWidth = c.getAttribute('width')*1;
        var yStep = Math.floor(canvasHeight/SOM_HEIGHT);
        var xStep = Math.floor(canvasWidth/SOM_WIDTH);
        var s;

        var ctx=c.getContext("2d");

        var _y = 0;
        var _x = 0;
        for ( y = 0; y < SOM_HEIGHT; y++ )
        {
            _x = 0;
            for ( x = 0; x < SOM_WIDTH; x++ )
            {
                s = som[y][x];
                ctx.fillStyle = koh_RGBStr(Math.floor(s.w[0]*255), Math.floor(s.w[1]*255), Math.floor(s.w[2]*255));
                ctx.fillRect( _x, _y, xStep, yStep );
                _x += xStep;
            } // end for
            _y += yStep;
        } // end for y
    }

    var somNumIterations = 1000;
    var somIteration = 1;
    var somMapRadius = _max( SOM_HEIGHT, SOM_WIDTH ) / 2.0;
    var somLearningRate = 0.00000001;
    var somTimeConst = somNumIterations / Math.log( somMapRadius );
    var SOM_NUM_WEIGHTS = 3;
    function koh_Create()
    {
        var y, x, z;
        var som = new Array( SOM_HEIGHT );
        for ( y = 0; y < SOM_HEIGHT; y++ )
        {
            som[y] = new Array( SOM_WIDTH );
            for ( x = 0; x < SOM_WIDTH; x++ )
            {
                var weight = new Array( SOM_NUM_WEIGHTS );
                for ( z = 0; z < SOM_NUM_WEIGHTS; z++ )
                    weight[z] = _rnd_Int( 0, 1 );
                som[y][x] = {
                    y: y,
                    x: x,
                    w: weight
                };
            } // end for x
        } // end for x
        return som;
    }

    function SQR( a )
    {
        return a * a;
    }

    function som_Dist( v0, v1 )
    {
        var dist = 0.0;
        var z;
        for ( z = 0; z < SOM_NUM_WEIGHTS; z++ )
            dist += SQR( Math.abs( v1[z] - v0[z] ) );
        return Math.sqrt( dist );
    }

    function som_FindBMU( som, testVec )
    {
        var d, bestSoFar = 99999;
        var i, bestIdx = -1;
        var s;
        for ( i = 0; i < som.length; i++ )
        {
            d = som_Dist( s.w, testVec );
            if ( bestSoFar > d )
            {
                bestSoFar = d;
                bestIdx = i;
            }
        } // end for i

        _assert( bestIdx != -1, 'Best idx not set' );
        return bestIdx;
    }

    function som_AdjustWeights( sample, v, learningRate, influence )
    {
        var z;
        for ( z = 0; z < SOM_NUM_WEIGHTS; z++ )
        {
            v[z] += learningRate * influence * ( sample[z] - v[z] );
        } // end for z
        return v;
    }

    function som_DistSq( s0, s1 )
    {
        var x = Math.abs( s1.x - s0.x );
        var y = Math.abs( s1.y - s0.y );
        return Math.sqrt( SQR(x) + SQR(y) );
    }

    var somSamples = [
            [1,0,0],
            [0,1,0],
            [0,0,1]
    ];

    function koh_Train( som )
    {
        var thisVector = _rnd_Int( 0, somSamples.length-1 );
        var bmu = som_FindBMU( som, somSamples[thisVector] );
        var sBmu = som[bmu];
        var neighRadius;
        var neighRadiusSqrt;
        var distSq;
        var influence;
        var i;
        var s;

        somNumIterations--;
        neighRadius = somMapRadius * Math.exp( -somIteration/somTimeConst );
        neighRadiusSqrt = neighRadius*neighRadius;

        for ( i = 0; i < som.length; i++ )
        {
            s = som[i];
            distSq = som_DistSq( s, sBmu );
            if ( neighRadiusSqrt > distSq )
            {
                influence = Math.exp( -neighRadiusSqrt/(distSq*2.0) );
                som_AdjustWeights( somSamples[thisVector], s.w, somLearningRate, influence );
            } // end if
        } // end for i

        somLearningRate += 0.01 * Math.exp( -somIteration/somNumIterations );
        somIteration++;

    }

    function koh_Main()
    {
        var som = koh_Create();
        koh_Show( som );
    }
    koh_Main();
</script>

</body>
</html>