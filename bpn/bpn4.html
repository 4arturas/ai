<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title></title>
</head>
<body>

<script type="text/javascript">
    function _floor( v )
    {
        return Math.floor( v );
    }
    function _rnd_Int( x, y )
    {
        return _floor(
                Math.random() * ( y - x + 1 ) + x
        );
    }
    function _rnd_Real( x, y )
    {
        return Math.random() * ( y - x ) + x;
    }
    function _log( l )
    {
        console.log( l );
    }
    function _assert( a, msg )
    {
        if ( !a )
            alert( 'ASEERT FAIL: ' + msg );
    }
    function _max( x, y )
    {
        return x > y ? x : y;
    }
    function _min( x, y )
    {
        return x < y ? x : y;
    }
</script>

<div id="bpnMsg"></div>
<style type="text/css">
    #bpnTable { border: 1px solid black; }
    #bpnTable td { border: 1px solid black; width: 90px; padding: 5px; vertical-align: top; }
</style>
<table id="bpnTable" cellpadding="0" cellspacing="0"></table>

<script type="text/javascript">
    var BPN_HI = 1.0;
    var BPN_LO = 0.0;
    var BPN_BIAS = 1.0;

    var BPN_INP = 2;
    var BPN_HID = 4;
    var BPN_OUT = 1;
    var bpnLayer = [BPN_INP,BPN_HID,BPN_OUT];

    function bpn_Msg( msg )
    {
        document.getElementById('bpnMsg').innerHTML = msg;
    }

    function bpn_Create( )
    {
        var y, x, z;
        var bpn = {
            val: new Array( bpnLayer.length ),
            err: new Array( bpnLayer.length ),
            weight: new Array( bpnLayer.length ),
            td: new Array( bpnLayer.length )
        };
        for ( x = 0; x < bpnLayer.length; x++ )
        {
            bpn.val[x] = new Array( bpnLayer[x]+1 );
            bpn.err[x] = new Array( bpnLayer[x]+1 );
            bpn.weight[x] = new Array( bpnLayer[x]+1 );
            bpn.td[x] = new Array( bpnLayer[x]+1 );
            for ( y = 0; y < bpnLayer[x]+1; y++ )
            {
                bpn.val[x][y] = 0.0;
                bpn.err[x][y] = 0.0;
                bpn.td[x][y] = document.createElement('td');
            }
            bpn.val[x][0] = BPN_BIAS;
        } // end for x

        for ( x = 0; x < bpn.val.length-1; x++ )
        {
            for (y = 0; y < bpn.val[x].length; y++)
            {
                bpn.weight[x][y] = new Array( bpn.val[x+1].length + 1);
                for (z = 0; z < bpn.weight[x][y].length; z++)
                    bpn.weight[x][y][z] = _rnd_Real(-1, +1);
            } // end for y
        } // end for x
        return bpn;
    }

    function bpn_EmitNode( y, x, msg )
    {
        var td = document.getElementById(y+'_'+x);
        td.innerHTML = msg;
    }

    function bpn_CreateTable( bpn )
    {
        var y, x, z;
        var bpnTable = document.getElementById('bpnTable');
        var tr, td;
        var maxRows = -Infinity;
        for ( x = 0; x < bpn.val.length; x++ )
        {
            maxRows = _max( maxRows, bpn.val[x].length );
        }
        for ( y = 0; y < maxRows; y++ )
        {
            tr = document.createElement('tr');
            bpnTable.appendChild( tr );
            for (x = 0; x < bpnLayer.length; x++)
            {
                td = document.createElement('td');
                tr.appendChild( td );
                td.setAttribute('id',y+'_'+x);
                bpn_EmitNode( y, x, '&nbsp;' );
            } // end for x
        } // end for y
    }

    function bpn_Substr( v )
    {
        if ( v == null )
            return 'not impl';
        v += '';
        return v.substr( 0, 6 );
    }

    function bpn_EmitTable( bpn )
    {
        var y, x, z;
        var msg;
        var w;
        for ( x = 0; x < bpn.val.length; x++ )
        {
            for ( y = 0; y < bpn.val[x].length; y++ )
            {
                msg = 'val: ' + bpn_Substr(bpn.val[x][y]);
                msg += '<br>err: ' + bpn_Substr(bpn.err[x][y]);
                if ( bpn.weight[x][y] != null )
                {
                    for (z = 0; z < bpn.weight[x][y].length; z++)
                    {
                        msg += '<br>' + bpn_Substr( bpn.weight[x][y][z] );
                    } // end for z
                }
                bpn_EmitNode( y, x, msg );
            }
        } // end for x
    }

</script>

<script type="text/javascript">


    function bpn_CreateTrainData()
    {
        var trainInp = [
            [1,1]
        ];
        var trainOut = [
            [1]
        ];
        return [ trainInp, trainOut ];
    }
    function bpn_SetInput( bpn, Inp )
    {
        var y;
        for ( y = 1; y < bpn.val[0].length; y++ )
            bpn.val[0][y] = Inp[y-1];
    }

    function bpn_Propagate( bpn )
    {
        var y, x, z;
        var Out;
        for ( x = 1; x < bpn.val.length; x++ )
        {
            for ( y = 1; y < bpn.val[x].length; y++ )
            {
                Out = 0;
                for ( z = 0; z < bpn.val[x-1].length; z++ )
                    Out += bpn.weight[x-1][z][y] * bpn.val[x-1][z];
                bpn.val[x][y] = 1.0 / ( 1.0 + Math.exp(-Out) );
            } // end for y
        } // end for y
    }

    function bpn_ComputeOutputError( bpn, Target )
    {
        var y;
        var Out, Err;
        var netError = 0.0;
        var x = bpn.err.length-1;
        for ( y = 1; y < bpn.err[x].length; y++ )
        {
            Out = bpn.val[x][y];
            Err = Target[y-1] - Out;
            bpn.err[x][y] = Err * Out * ( 1.0 - Out );
            netError += 0.5 * (Err*Err);
        }
        return netError;
    }

    function bpn_Backpropagate( bpn )
    {
        var y, x, z;
        var Err, Out;
        for ( x = bpn.val.length-2; x >= 1; x-- )
        {
            for ( y = 1; y < bpn.val[x-1].length; y++ )
            {
                Out = bpn.val[x-1][y];
                Err = 0;
                for ( z = 1; z < bpn.val[x].length; z++ )
                    Err += bpn.weight[x][z][y] * bpn.err[x][z];
                bpn.err[x-1][y] = Err * Out * ( 1.0 - Out );
            } // end for y
        } // end for x
    }

    function bpn_AdjustWeight( bpn )
    {
        var y, x, z;
        var Out, Err;
        for ( x = 1; x < bpn.val.length; x++ )
        {
            for ( y = 1; y < bpn.val[x].length; y++ )
            {
                Err = bpn.err[x][y];
                for ( z = 0; z < bpn.val[x-1].length; z++ )
                {
                    Out = bpn.val[x-1][z];
                    _log( Out );
                    bpn.weight[x][y][z] += 0.5 * Err * Out;
                }
            } // end for y
        } // end for y
    }


    function bpn_Epoch( bpn, epoch, trainInp, trainOut )
    {
        if ( epoch == 100 ) return;
        var n;
        for ( n = 0; n < trainInp.length; n++ )
        {
            bpn_SetInput( bpn, trainInp[n] );
            bpn_Propagate( bpn );
            bpn_ComputeOutputError( bpn, trainOut[n] );
            bpn_Backpropagate( bpn );
            bpn_AdjustWeight( bpn );
            bpn_EmitTable( bpn );
        } // end for n

        setTimeout( function() {
            bpn_Epoch( bpn, epoch+1, trainInp, trainOut );
        }, 1000 );
    }
    function bpn_EntryPoint()
    {
        var bpn = bpn_Create();
        var train = bpn_CreateTrainData();
        var trainInp = train[0];
        var trainOut = train[1];

        bpn_CreateTable( bpn );
        bpn_EmitTable( bpn );

        bpn_Epoch( bpn, 0, trainInp, trainOut );
    }
    bpn_EntryPoint();
</script>

</body>
</html>